{
  "name": "oauth-shim",
  "version": "0.1.2",
  "description": "OAuth2 shim for OAuth1 services, works with the clientside library HelloJS",
  "main": "index.js",
  "scripts": {
    "test": "mocha -w test"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com/MrSwitch/node-oauth-shim"
  },
  "keywords": [
    "oauth",
    "oauth-proxy",
    "oauth-shim",
    "rest"
  ],
  "author": {
    "name": "Andrew Dodson",
    "email": "andrewjdodson@gmail.com"
  },
  "license": "BSD",
  "bugs": {
    "url": "https://github.com/MrSwitch/node-oauth-shim/issues"
  },
  "dependencies": {
    "crypto": "0.0.3"
  },
  "devDependencies": {
    "should": ">= 0.0.0",
    "express": "*",
    "connect": "*",
    "supertest": "*"
  },
  "readme": "# OAuth-shim\r\nThis node module provides a \"shim\" service for clientside web apps adopting serverside OAuth2 or OAuth1 authentication but fighting to keep it all the browser, and shims the tedious dog legging through servers that has become OAuth1's curse.\r\n\r\n\r\n## Use case\r\n\r\nPopular API's like Twitter, Dropbox and Yahoo require this server-to-server authentication paradigm. What oauthshim does is set up a RESTful service which shims up these web API's. This is used by clientside libraries like [HelloJS](http://adodson.com/hello.js) as a fallback to keep everything running in the client.\r\n\r\n## Demo\r\n\r\n[https://auth-server.herokuapp.com](https://auth-server.herokuapp.com) is a service which utilizes this package. You can register your own Application Key and Secret there if you dont want to set your own up. But for production you shouldn't rely on that service.\r\n\r\n\r\n## Installing on the server\r\n\r\nInstall the package\r\n\r\n\tnpm install oauth-shim\r\n\r\n\r\n## Using with ExpressJS\r\n\t\r\n\tvar oauthshim = require('oauth-shim'),\r\n\t\texpress = require('express');\r\n\r\n\tvar app = express();\r\n\tapp.all('/oauthproxy', oauthshim.request);\r\n\r\n\t// Initiate the shim with Client ID's e.g.\r\n\toauthshim.init({\r\n\t\t// key : Secret\r\n\t\t'12345' : 'secret678910',\r\n\t\t'abcde' : 'secretfghijk'\r\n\t});\r\n\r\n\t// Print request->response to console.\r\n\toauthshim.debug = true;\r\n\r\nThe code above says apply the shim to all requests to the pathname `/oauthproxy`.\r\n\r\n## Using with ConnectJS\r\n\r\nChange `oauthshim.request` to `oauthshim.listen`\r\n\r\n\r\n### Asynchronsly access secret\r\n\r\nIf you want to return clientID's asynchronosly (perhaps you want to look up from a database) then override the getCredentials method. Here's the basics e.g...\r\n\r\n\toauthshim.getCredentials = function(id,callback){\r\n\t\t// Return\r\n\t\tif(id === '12345'){\r\n\t\t\tcallback('secret678910');\r\n\t\t}\r\n\t\tif(id === 'abcde'){\r\n\t\t\tcallback('secretfghijk');\r\n\t\t}\r\n\t}\r\n\r\n\r\n## Authentication API\r\n\r\n### Authentication OAuth 2.0\r\n\r\nThe OAuth2 flow for the shim starts after a web application sends a client out to a providers site to grant permissions. The response is an authorization code \"[AUTH_CODE]\" which is returned to your site, this needs to be exchanged for an Access Token. Your page then needs to send this code to an //auth-server with your client_id in exhchange for an access token, e.g.\r\n\r\n\r\n\t?redirect_uri=[REDIRECT_PATH]\r\n\t&code=[AUTH_CODE]\r\n\t&client_id=[APP_KEY]\r\n\t&state=[STATE]\r\n\t&grant_url=[PROVIDERS_OAUTH2_GRANT_URL]\r\n\r\n\r\nThe client will be redirected back to the location of [REDIRECT_PATH], with the contents of the server response as well as whatever was defined in the [STATE] in the hash. e.g...\r\n\r\n\r\n\t[REDIRECT_PATH]#state=[STATE]&access_token=ABCD1233234&expires=123123123\r\n\r\n\r\n\r\n### Authentication OAuth 1.0 &amp; 1.0a\r\n\r\nOAuth 1.0 has a number of steps so forgive the verbosity here. An app is required to make an initial request to the //auth-server, which in-turn initiates the authentication flow.\r\n\r\n\r\n\t?redirect_uri=[REDIRECT_PATH]\r\n\t&client_id=[APP_KEY]\r\n\t&request_url=[OAUTH_REQUEST_TOKEN_URL]\r\n\t&auth_url=[OAUTH_AUTHORIZATION_URL]\r\n\t&token_url=[OAUTH_TOKEN_URL]\r\n\t&state=[STATE]\r\n\r\n\r\nThe OAuthShim signs the client request and redirects the user to the providers login page defined by `[OAUTH_AUTHRIZATION_URL]`.\r\n\r\nOnce the user has signed in they are redirected back to a page on the developers app defined by `[REDIRECT_PATH]`. \r\n\r\nThe provider should have included an oauth_callback parameter which was defined by //auth-server, this includes part of the path where the token can be returned for an access token. The total path response shall look something like this.\r\n\r\n\r\n\t[REDIRECT_PATH]\r\n\t?state=[STATE]\r\n\t&proxy_url=https://auth-server.herokuapp.com/proxy\r\n\t&client_id=[APP_KEY]\r\n\t&token_url=[OAUTH_TOKEN_URL]\r\n\t&oauth_token=abc12465\r\n\r\n\r\nThe page you defined locally as the `[REDIRECT_PATH]`, must then construct a call to //auth-server to exchange the unauthorized oauth_token for an access token. This would look like this...\r\n\r\n\r\n\t?oauth_token=abc12465\r\n\t&redirect_uri=[REDIRECT_PATH]\r\n\t&client_id=[APP_KEY]\r\n\t&state=[STATE]\r\n\t&token_url=[OAUTH_TOKEN_URL]\r\n\r\n\r\nFinally the //auth-server returns the access_token to your redirect path and its the responsibility of your script to store this in the client in order to make subsequent API calls.\r\n\r\n\t[REDIRECT_PATH]#state=[STATE]&access_token=ABCD1233234&expires=123123123\r\n\r\n\r\nThis access token still needs to be signed via //auth-server every time an API request is made - read on...\r\n\r\n\r\n\r\n\r\n\r\n## API: Signing API Requests\r\n\r\nThe OAuth 1.0 API requires that each request is uniquely signed with the application secret. This restriction was removed in OAuth 2.0, so only applied to OAuth1 endpoints.\r\n\r\n### A simple GET Redirect\r\n\r\nTo sign a request to `[API_PATH]`, use the `[ACCESS_TOKEN]` returned in OAuth 1.0 above and send to the auth-server. \r\n\r\n\t?access_token=[ACCESS_TOKEN]\r\n\t&path=[API_PATH]\r\n\r\nThe oauth shim signs and redirects the requests to the `[API_PATH]` e.g.\r\n\r\n\t[API_PATH]?oauth_token=asdf&oauth_consumer_key=asdf&...&oauth_signature=1234\r\n\r\nIf the initial request was other than a GET request, it will be proxied through the oauthshim by default. CORS headers would be added to the response from the end server.\r\n\r\n### Signing a Request and returning the Signed Request URL\r\n\r\nIf the end server supports CORS and a lot of data is expected to be either sent or returned. The burded on the oauthshim can be lessened by merely returning the signed request url and handling the action elsewhere. \r\n\r\n\t?access_token=[ACCESS_TOKEN]\r\n\t&path=[API_PATH]\r\n\t&then=return\r\n\r\n### Proxying the Request\r\nConversely forcing the request to proxy through the oauthshim is achieved by applying the flag then=proxy. CORS headers are added to the response. This naturally is the slow route for data and is best avoided.\r\n\r\n\t?access_token=[ACCESS_TOKEN]\r\n\t&path=[API_PATH]\r\n\t&then=proxy\r\n\r\n\r\n### Change the method and add callback for JSONP\r\nAdd a JSONP callback function and override the method. E.g.\r\n\r\n\t?access_token=[ACCESS_TOKEN]\r\n\t&path=[API_PATH]\r\n\t&then=return\r\n\t&method=post\r\n\t&callback=myJSONP\r\n\r\n\r\n## Contributing\r\n\r\nDon't forget to run the tests. \r\n\r\n\t# Install the test dependencies.\r\n\r\n\tnpm install -l\r\n\r\n\t# Run the tests, continuously\r\n\r\n\tnpm test\r\n\r\n\t# Single\r\n\r\n\tmocha test\r\n\r\n\r\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/MrSwitch/node-oauth-shim",
  "_id": "oauth-shim@0.1.2",
  "dist": {
    "shasum": "6a82c4dc2e6be7d011a1ce113a0646e89b40a6f1"
  },
  "_from": "oauth-shim@",
  "_resolved": "https://registry.npmjs.org/oauth-shim/-/oauth-shim-0.1.2.tgz"
}
